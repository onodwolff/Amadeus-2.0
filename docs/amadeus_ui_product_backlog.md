# Дорожная карта Amadeus 2.0 до пользовательского релиза

Этот документ агрегирует текущее состояние Amadeus 2.0 и формирует расширенный набор задач для Codex. Цель — довести систему до полнофункционального пользовательского интерфейса, подключенного к реальному ядру NautilusTrader, с устойчивым бэкендом, DevOps-практиками и эксплуатационной документацией.

## 1. Снимок текущего состояния
- **Бэкенд.** FastAPI-приложение `gateway` объединяет маршруты по данным, стратегиям, ордерам, ключам и рискам, используя Pydantic-схемы и SQLAlchemy для работы с хранилищем. Модули `nautilus_service` и `nautilus_engine_service` предоставляют заглушку и частичную интеграцию с NautilusTrader, регистрируя адаптеры и выдавая события в WebSocket-шину.【F:backend/gateway/app/main.py†L1-L200】
- **Фронтенд.** Angular-приложение уже содержит shell-компонент с навигацией, страницы узлов, портфеля, ордеров, рынка, стратегий и риск-панели, каждая из которых использует signals, WebSocket-подписки и standalone-компоненты для визуализации текущего состояния.【F:frontend/amadeus-ui/src/app/app.component.html†L1-L55】【F:frontend/amadeus-ui/src/app/orders/orders.page.ts†L1-L200】【F:frontend/amadeus-ui/src/app/portfolio/portfolio.page.ts†L1-L156】
- **Интеграционные планы.** В `docs/nautilus_integration_plan.md` и `docs/nautilus_integration_task_breakdown.md` уже определены этапы подключения реального движка NautilusTrader, но без фокуса на UX, эксплуатацию и подготовку к пользовательскому релизу.【F:docs/nautilus_integration_plan.md†L1-L43】【F:docs/nautilus_integration_task_breakdown.md†L1-L115】

## 2. Основные пробелы и риски
1. **Неполная интеграция NautilusTrader.** Mock-сервис подменяет реальные метрики и состояния, из-за чего UI не демонстрирует поведение боевого ядра и не поддерживает расширенные типы ордеров.
2. **Недостаточная UX-проработка.** Отсутствуют дизайн-системы, адаптивные макеты, сценарии онбординга и состояния «пустых» данных, что делает интерфейс трудным для конечных трейдеров.
3. **Расхождение API/фронта.** Не формализованы контракты, отсутствуют автогенерация клиентов и валидация схем, что усложняет совместную доработку.
4. **Мониторинг и диагностика.** Нет централизованного логгинга, метрик и алертов для backend/frontend, отсутствует хранение логов узлов и экспорт телеметрии.
5. **DevOps и безопасность.** Нужны конфигурации для staging/production, секрет-менеджмент, политика ключей и пайплайны поставки.
6. **Документация и DX.** Не хватает гайдов для разработчиков, QA и операторов, нет UX-спецификаций и регламентов поддержки.

## 3. Принципы реализации
- **Фазовый подход.** Реализация делится на подготовительный этап (диагностика и архитектура), интеграционный (ядро и данные), UX/продуктовый (интерфейс и онбординг), эксплуатационный (мониторинг, безопасность) и завершающий (документация, релиз).
- **Согласованные контракты.** Любые изменения API сопровождаются обновлением схем и генерацией TypeScript-клиентов, чтобы фронтенд автоматически получал типы.
- **Контроль качества.** Каждая задача заканчивается тестами (unit/e2e), проверками стиля и документацией.

## 4. Масштабный бэклог задач для Codex

### Фаза 0. Диагностика и архитектурная фиксация
1. Провести аудит текущего REST/WebSocket API: задокументировать эндпоинты, payload-ы и ошибки, сформировать OpenAPI-спеку и схемы событий.
2. Внедрить автогенерацию клиентских SDK (FastAPI → TypeScript) и сравнить с существующими вручную написанными клиентами; подготовить план миграции.
3. Описать схему данных PostgreSQL и Redis, провести ревизию Alembic-миграций, определить недостающие индексы и ограничения.
4. Сформировать архитектурный документ с диаграммами потоков данных между NautilusTrader, gateway и UI, включая отказоустойчивость.
5. Настроить базовый CI (lint + тесты для backend/frontend) и собрать метрики покрытия, чтобы отслеживать прогресс при масштабных изменениях.

### Фаза 1. Реальное ядро NautilusTrader и данные
1. Завершить задачи 1.1–1.4 из текущего плана: хранение конфигураций, запуск backtest/live узлов, стрим телеметрии и логику graceful shutdown.
2. Расширить WebSocket-шину: определить единый формат событий (узлы, портфель, ордера, риск) и добавить версионирование сообщений.
3. Обновить бэкендовые маршруты `/orders`, `/portfolio`, `/risk` для поддержки расширенных типов ордеров, маржинальных показателей и риск-алертов NautilusTrader.
4. Реализовать хранение логов узлов с возможностью скачивания и фильтрации по периоду, уровню и источнику.
5. Настроить процессы загрузки исторических данных (адаптеры Databento/Tardis) с кешированием и API для запроса статуса подготовки датасетов.

### Фаза 2. UX-редизайн и интерфейсные сценарии
1. Разработать дизайн-систему: палитры, типографику, spacing, интерактивные состояния, адаптивные брейкпоинты и UI-кит компонентов.
2. Переработать layout shell: адаптивная sidebar, breadcrumb, глобальный поиск и быстрый доступ к запускам узлов и стратегиям.
3. Узлы (Nodes):
   - Создать мастера запуска с пошаговыми формами (конфигурация, адаптеры, риск-параметры) и предпросмотром YAML/JSON.
   - Добавить живой таймлайн событий, отображение статуса подключения адаптеров и визуализацию метрик (PnL, латентность, ресурсы) на графиках.
   - Реализовать сценарии управления (перезапуск, остановка, клонирование конфигурации) и подтверждения опасных действий.
4. Портфель:
   - Визуализировать equity curve, маржинальные требования, exposure по venue/активам, добавить heatmap позиций.
   - Обновить фильтры, добавить сохранённые представления и экспорт в CSV/Excel.
5. Ордеры:
   - Создать многошаговый ордер-трилоджик (ticket) с поддержкой условных, OCO/OTO ордеров, выбором адаптеров и проверкой доступной маржи.
   - Добавить real-time обновления состояния с подсветкой изменений, панель исполнений и журнал действий.
6. Риск и алерты:
   - Построить дашборд с уровнем риска, триггерами и сценариями эскалации (email/webhook).
   - Позволить конфигурировать пороги и получать уведомления в notification center.
7. Маркет-данные и стратегии:
   - Инструменты выбора активов, просмотр рыночной глубины, свечные графики, результаты backtest с визуализацией.
   - Каталог стратегий с карточками, версиями, описаниями и кнопками «Запустить»/«Тестировать».
8. Состояния «нет данных» и onboarding: страницы-пустышки, onboarding-тур, справка и видеогайды.

### Фаза 3. Обслуживание, безопасность и DevOps
1. Настроить централизованный логгинг (ELK/OpenSearch) и метрики (Prometheus/Grafana), включая сбор фронтендовых vitals.
2. Внедрить distributed tracing между UI, gateway и NautilusTrader (OpenTelemetry).
3. Реализовать систему ролей и разрешений (RBAC) с управлением API-ключами, аудитом действий и политиками хранения секретов.
4. Подготовить Helm charts/docker-compose для локального, staging и production окружений, описать health-checks и стратегии деплоя.
5. Автоматизировать smoke-тесты после деплоя: запуск базового узла, исполнение тестового ордера, проверка стримов.

### Фаза 4. Качество, тестирование и документация
1. Покрыть backend unit и интеграционными тестами критичные сценарии (запуск узла, отправка ордеров, риск-алерты, портфельные расчёты).
2. Настроить фронтендовые unit-тесты (Jest) и e2e-тесты (Cypress/Playwright) для ключевых пользовательских потоков.
3. Создать нагрузочные тесты для WebSocket и REST, убедиться в способности обрабатывать множественные узлы и ордера.
4. Обновить документацию: гайды для разработчиков, операторов, трейдеров; инструкции по восстановлению и disaster recovery.
5. Подготовить релизный чеклист, включающий валидацию конфигураций, резервное копирование БД и план обратного отката.

### Фаза 5. Пострелизные инициативы
1. Встроить аналитику пользовательского поведения (безопасно и анонимно) для оценки UX.
2. Реализовать marketplace стратегий и шаблонов конфигураций, поддержать отзывы и рейтинги.
3. Добавить API/SDK для внешних AI-агентов, интегрировать с пайплайнами AutoML/AutoBacktest и обеспечить безопасный деплой.
4. Расширить мобильную поддержку (responsive + PWA), подготовить roadmap для native-клиентов.
5. Сформировать план развития комьюнити: открытые API, документация по расширению адаптеров, примеры кастомных стратегий.

## 5. Следующие шаги
1. Утвердить фазу 0 и назначить ответственных по направлениям (backend, frontend, DevOps, UX).
2. Подготовить оценки трудоёмкости и зависимости между задачами, определить quick wins для ближайших спринтов.
3. Запустить регулярные синки между командами, обновлять данный документ по мере закрытия задач и появления новых требований.
